// Copyright 2023-2099 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.
//
// #include <Framework/AnalysisTask.h>
#include <Framework/AnalysisHelpers.h>
#include <Framework/AnalysisTask.h>
#include <Generators/AODToHepMC.h>
#include "Wrapper.h"

template <typename T>
using OutputObj = o2::framework::OutputObj<T>;

//--------------------------------------------------------------------
using o2::framework::ConfigParamKind;
using o2::framework::ConfigParamSpec;

// -------------------------------------------------------------------
void customize(std::vector<ConfigParamSpec>& workflowOptions)
{
  using o2::framework::VariantType;

  workflowOptions.emplace_back(ConfigParamSpec{"hepmc-aux", //
                                               VariantType::Bool,
                                               false, //
                                               {"Also process auxiliary "
                                                "HepMC tables"},
                                               ConfigParamKind::kProcessFlag});
}

//--------------------------------------------------------------------
// This _must_ be included after our "customize" function above, or
// that function will not be taken into account.
#include <Framework/runDataProcessing.h>

//--------------------------------------------------------------------
/** A DPL to process simulation output (@c o2::aod::MCCollision
 *  and @c o2::aod::McParticles via DPL @c o2-sim-kine-publisher)
 *  in Rivet analyses.
 *
 *  The code uses the service classes @c o2::eventgen::AODToHepMC and
 *  @c o2::rivet::Wrapper to fulfill this task.
 *
 *  The output (result of the analyses) is stored in a @c
 *  o2::rivet::RivetAOs object.  This object essentially contain a
 *  string containing the YODA objects generated by the Rivet
 *  Analyses.  Therefore, to get the output of the Rivet analyses,
 *  one need to retrieve the object from the output file.
 *
 *  @code
 *  gROOT->LoadMacro("O2RivetOutput.h+");
 *  TFile* ar = TFile::Open("AnalsysisResults.root","READ");
 *  o2::rivet::RivetAOs* ro =
 *  static_cast<o2::rivet::RivetAOs*>(ar->Get("o2-analysis-mm-rivet/"
 *  "o2::rivet::RivetAOs"));
 *  @endcode
 *
 *  and then write that to disk
 *
 *  @code
 *  ro->SaveAs("Rivet.yoda");
 *  @endcode
 *
 *  Alternatively one can pass the option @c --rivet-dump
 *  Rivet.yoda to get the (partial) output written to disk.
 *
 *  One can then process the YODA file as per normal Rivet
 *  analyses, for example in Python
 *
 *  @code
 *  from yoda import read
 *  from matplotlib.pyplot import gca, ion
 *
 *  ion()
 *  aos  = read('Rivet.yoda')
 *  hist = aos['/ALICE_YYYY_I1234567/d01-x01-y01']
 *  ax   = gca()
 *  ax.errorbar(hist.xMids(),hist.yVals(),hist.yErrs())
 *  @endcode
 *
 */
struct Task1 {
  using Converter = o2::eventgen::AODToHepMC;
  using Wrapper = o2::rivet::Wrapper;
  using RivetAOsPtr = typename Wrapper::RivetAOsPtr;

  /** Our converter */
  Converter mConverter;
  /** Our wrapper */
  Wrapper mWrapper;
  /** Our output wrapped */
  OutputObj<o2::rivet::RivetAOs> mOutput{o2::rivet::RivetAOs()};

  /** @{
      @name Container types */
  using Headers = Converter::Headers;
  using Header = Converter::Header;
  using Tracks = Converter::Tracks;
  using XSections = Converter::XSections;
  using XSection = Converter::XSection;
  using PdfInfos = Converter::PdfInfos;
  using PdfInfo = Converter::PdfInfo;
  using HeavyIons = Converter::HeavyIons;
  using HeavyIon = Converter::HeavyIon;
  /** @} */

  /** Initialize the job */
  void init(o2::framework::InitContext&)
  {
    mConverter.init();
    mWrapper.init(mOutput.object);
  }
  /** Process input */
  void process(Header const& collision,
               Tracks const& tracks,
               XSections const& xsections,
               PdfInfos const& pdfs,
               HeavyIons const& heavyions)
  {
    LOG(info) << "=== Processing tracks and auxiliary header information";
    assert(xsections.size() == 1);
    assert(heavyions.size() == 1);
    assert(pdfs.size() == 1);
    mConverter.process(collision,
                       xsections,
                       pdfs,
                       heavyions);
    mConverter.process(collision, tracks);
    mWrapper.process(mConverter.mEvent);
  }
};
//--------------------------------------------------------------------
/** Same as @c Task1 above, except only header and tracks are
 *  processes (i.e., no auxiliary information from */
struct Task2 {
  using Converter = o2::eventgen::AODToHepMC;
  using Wrapper = o2::rivet::Wrapper;
  using RivetAOsPtr = typename Wrapper::RivetAOsPtr;

  /** Our converter */
  Converter mConverter;
  /** Our wrapper */
  Wrapper mWrapper;
  /** Our output wrapped */
  OutputObj<o2::rivet::RivetAOs> mOutput{o2::rivet::RivetAOs()};

  /** @{
      @name Container types */
  using Headers = Converter::Headers;
  using Header = Converter::Header;
  using Tracks = Converter::Tracks;
  /** @} */

  /** Initialize the job */
  void init(o2::framework::InitContext&)
  {
    mConverter.init();
    mWrapper.init(mOutput.object);
  }
  /** Process input */
  void process(Header const& collision,
               Tracks const& tracks)
  {
    // processAux(collision, xsections, pdfs, heavyions);
    LOG(info) << "Processing header and tracks";
    mConverter.process(collision, tracks);
    mWrapper.process(mConverter.mEvent);
  }
};

//--------------------------------------------------------------------
/** Same as @c Task1 above, except the auxiliary information is only
 *  optionally passed.  Does not work for some odd reason.  See also
 *  the applicaiton @c o2-sim-mcevent-to-aod */
struct Task3 {
  using Converter = o2::eventgen::AODToHepMC;
  using Wrapper = o2::rivet::Wrapper;
  using RivetAOsPtr = typename Wrapper::RivetAOsPtr;

  /** Our converter */
  Converter mConverter;
  /** Our wrapper */
  Wrapper mWrapper;
  /** Our output wrapped */
  OutputObj<o2::rivet::RivetAOs> mOutput{o2::rivet::RivetAOs()};

  /** @{
   *  @name Container types */
  using Headers = Converter::Headers;
  using Header = Converter::Header;
  using Tracks = Converter::Tracks;
  using XSections = Converter::XSections;
  using XSection = Converter::XSection;
  using PdfInfos = Converter::PdfInfos;
  using PdfInfo = Converter::PdfInfo;
  using HeavyIons = Converter::HeavyIons;
  using HeavyIon = Converter::HeavyIon;
  /** @} */

  /** Initialize the job */
  void init(o2::framework::InitContext&)
  {
    mConverter.init();
    mWrapper.init(mOutput.object);
  }
  /** Process events */
  void processAux(Header const& collision,
                  XSections const& xsections,
                  PdfInfos const& pdfs,
                  HeavyIons const& heavyions)
  {
    LOG(info) << "=== Processing auxiliary header information";
    assert(xsections.size() == 1);
    assert(heavyions.size() == 1);
    assert(pdfs.size() == 1);
    mConverter.process(collision,
                       xsections,
                       pdfs,
                       heavyions);
  }
  /** Process input */
  void process(Header const& collision,
               Tracks const& tracks)
  {
    LOG(info) << "=== Processing tracks and header information";
    mConverter.process(collision, tracks);
    mWrapper.process(mConverter.mEvent);
  }
#if 0
  decltype(o2::framework::ProcessConfigurable{&Task3::processAux,
                                              "hepmx-auc", false,
                                              "Auxiliary info"})
    doprocessAux = o2::framework::ProcessConfigurable{&Task3::processAux,
                                                      "hepmc-aux", false,
                                                      "Auxillary info"};
#endif
};

//--------------------------------------------------------------------
using WorkflowSpec = o2::framework::WorkflowSpec;
using TaskName = o2::framework::TaskName;
using DataProcessorSpec = o2::framework::DataProcessorSpec;
using ConfigContext = o2::framework::ConfigContext;

WorkflowSpec defineDataProcessing(ConfigContext const& cfg)
{
  using o2::framework::adaptAnalysisTask;

  // Task1: One entry: header, tracks, auxiliary
  // Task2: One entry: header, tracks
  // Task3: Two entry: header, tracks, and auxiliary
  if (cfg.options().get<bool>("hepmc-aux"))
    return WorkflowSpec{
      adaptAnalysisTask<Task1>(cfg, TaskName{"o2-analysis-mm-rivet"})};
  return WorkflowSpec{
    adaptAnalysisTask<Task2>(cfg, TaskName{"o2-analysis-mm-rivet"})};
}
//
// EOF
//
